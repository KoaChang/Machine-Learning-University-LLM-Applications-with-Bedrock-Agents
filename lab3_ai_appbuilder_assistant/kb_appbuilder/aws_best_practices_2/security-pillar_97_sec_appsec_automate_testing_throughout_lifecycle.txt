{"page_content": "SEC11-BP02 Automate testing throughout the development and release lifecycle - Security PillarSEC11-BP02 Automate testing throughout the development and release lifecycle - Security PillarAWSDocumentationAWS Well-ArchitectedAWS Well-Architected FrameworkImplementation guidance Resources SEC11-BP02 Automate testing throughout the development and\n  release lifecycle\n      Automate the testing for security properties throughout the\n      development and release lifecycle. Automation makes it easier to\n      consistently and repeatably identify potential issues in software\n      prior to release, which reduces the risk of security issues in the\n      software being provided.\n    Desired outcome:  The goal of automated testing is to\n    provide a programmatic way of detecting potential issues early and often throughout the\n    development lifecycle. When you automate regression testing, you can rerun functional and\n    non-functional tests to verify that previously tested software still performs as expected after\n    a change. When you define security unit tests to check for common misconfigurations, such as\n    broken or missing authentication, you can identify and fix these issues early in the development\n    process. \n      Test automation uses purpose-built test cases for application\n      validation, based on the application\u2019s requirements and desired\n      functionality. The result of the automated testing is based on\n      comparing the generated test output to its respective expected\n      output, which expedites the overall testing lifecycle. Testing\n      methodologies such as regression testing and unit test suites are\n      best suited for automation. Automating the testing of security\n      properties allows builders to receive automated feedback without\n      having to wait for a security review. Automated tests in the form\n      of static or dynamic code analysis can increase code quality and\n      help detect potential software issues early in the development\n      lifecycle.\n    \nCommon anti-patterns: \n\n\n\n          Not communicating the test cases and test results of the\n          automated testing.\n        \n\n\n          Performing the automated testing only immediately prior to a\n          release.\n        \n\n\n          Automating test cases with frequently changing requirements.\n        \n\n\n          Failing to provide guidance on how to address the results of\n          security tests.\n        \n\nBenefits of establishing this best practice: \n\n\n\n          Reduced dependency on people evaluating the security\n          properties of systems.\n        \n\n\n          Having consistent findings across multiple workstreams\n          improves consistency.\n        \n\n\n          Reduced likelihood of introducing security issues into\n          production software.\n        \n\n\n          Shorter window of time between detection and remediation due\n          to catching software issues earlier.\n        \n\n\n          Increased visibility of systemic or repeated behavior across\n          multiple workstreams, which can be used to drive\n          organization-wide improvements.\n        \n\n Level of risk exposed if this best practice is not established:\n      Medium \nImplementation guidance \nAs you build your software, adopt various mechanisms for software testing to ensure that \n  you are testing your application for both functional requirements, based on your application\u2019s \n  business logic, and non-functional requirements, which are focused on application reliability, \n  performance, and security.\n\nStatic application security testing (SAST) analyzes your source code for anomalous security patterns, \nand provides indications for defect prone code. SAST relies on static inputs, such as \ndocumentation (requirements specification, design documentation, and design specifications) \nand application source code to test for a range of known security issues. Static code \nanalyzers can help expedite the analysis of large volumes of code. \nThe NIST Quality Group \n  provides a comparison of Source Code Security Analyzers, \n  which includes open source tools for Byte Code Scanners\u00a0and\u00a0Binary Code Scanners.\n\n        Complement your static testing with dynamic analysis security\n        testing (DAST) methodologies, which performs tests against the\n        running application to identify potentially unexpected behavior.\n        Dynamic testing can be used to detect potential issues that are\n        not detectable via static analysis. Testing at the code\n        repository, build, and pipeline stages allows you to check for\n        different types of potential issues from entering into your\n        code.\n        Amazon\n        CodeWhisperer provides code recommendations, including\n        security scanning, in the builder\u2019s IDE.\n        Amazon CodeGuru Reviewer can identify critical issues, security\n        issues, and hard-to-find bugs during application development,\n        and provides recommendations to improve code quality.\n      \n\n        The\n        Security\n        for Developers workshop uses AWS developer tools, such as\n        AWS CodeBuild,\n        AWS CodeCommit, and\n        AWS CodePipeline, for release pipeline automation that\n        includes SAST and DAST testing methodologies.\n      \n\n        As you progress through your SDLC, establish an iterative\n        process that includes periodic application reviews with your\n        security team. Feedback gathered from these security reviews\n        should be addressed and validated as part of your release\n        readiness review. These reviews establish a robust application\n        security posture, and provide builders with actionable feedback\n        to address potential issues.\n      \nImplementation steps \n\n\n\n            Implement consistent IDE, code review, and CI/CD tools that\n            include security testing.\n          \n\n\n            Consider where in the SDLC it is appropriate to block\n            pipelines instead of just notifying builders that issues\n            need to be remediated.\n          \n\n\n            The\n            Security\n            for Developers workshop provides an example of\n            integrating static and dynamic testing into a release\n            pipeline.\n          \n\n\n            Performing testing or code analysis using automated tools,\n            such as\n            Amazon CodeWhisperer integrated with developer IDEs, and\n            Amazon CodeGuru Reviewer for scanning code on commit, helps\n            builders get feedback at the right time.\n          \n\n\n            When building using AWS Lambda, you can use\n            Amazon Inspector to scan the application code in your\n            functions.\n          \n\n\n            When automated testing is included in CI/CD pipelines, you\n            should use a ticketing system to track the notification and\n            remediation of software issues.\n          \n\n\n            For security tests that might generate findings, linking to\n            guidance for remediation helps builders improve code\n            quality.\n          \n\n\n            Regularly analyze the findings from automated tools to\n            prioritize the next automation, builder training, or\n            awareness campaign.\n          \n\nResources \n\nRelated documents:\n\n\n\n\nContinuous\n          Delivery and Continuous Deployment\n\n\n\n\n\nAWS           DevOps Competency Partners\n\n\n\nAWS           Security Competency Partners for Application Security\n        \n\n\nChoosing\n          a Well-Architected CI/CD approach\n\n\n\nMonitoring\n          CodeCommit events in Amazon EventBridge and Amazon CloudWatch Events\n\n\n\nSecrets\n          detection in Amazon CodeGuru Review\n\n\n\nAccelerate\n          deployments on AWS with effective governance\n\n\n\nHow\n          AWS approaches automating safe, hands-off\n          deployments\n\n\n\nRelated videos:\n\n\n\nHands-off:\n          Automating continuous delivery pipelines at Amazon\n\n\n\nAutomating\n          cross-account CI/CD pipelines\n\n\n\nRelated examples:\n\n\n\nIndustry\n          awareness for developers\n\n\n\nAWS CodePipeline\n            Governance (GitHub) \n\n\nSecurity\n          for Developers workshop\n\n\n Javascript is disabled or is unavailable in your browser.To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.Document ConventionsSEC11-BP01 Train for application securitySEC11-BP03 Perform regular penetration testingDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.", "metadata": {"source": "https://docs.aws.amazon.com/wellarchitected/latest/security-pillar/sec_appsec_automate_testing_throughout_lifecycle.html", "title": "SEC11-BP02 Automate testing throughout the development and release lifecycle - Security Pillar", "description": "Automate the testing for security properties throughout the development and release lifecycle. Automation makes it easier to consistently and repeatably identify potential issues in software prior to release, which reduces the risk of security issues in the software being provided.", "language": "en-US"}}