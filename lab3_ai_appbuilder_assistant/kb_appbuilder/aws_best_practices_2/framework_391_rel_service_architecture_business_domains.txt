{"page_content": "REL03-BP02 Build services focused on specific business domains and functionality - AWS Well-Architected FrameworkREL03-BP02 Build services focused on specific business domains and functionality - AWS Well-Architected FrameworkAWSDocumentationAWS Well-ArchitectedFrameworkImplementation guidanceImplementation stepsResourcesREL03-BP02 Build services focused on specific business domains\n  and functionalityService-oriented architectures (SOA) define services with well-delineated functions defined by business needs. Microservices use domain models and bounded context to draw service boundaries along business context boundaries. Focusing on business domains and functionality helps teams define independent reliability requirements for their services. Bounded contexts isolate and encapsulate business logic, allowing teams to better reason about how to handle failures.\nDesired outcome: Engineers and business stakeholders jointly define bounded contexts and use them to design systems as services that fulfill specific business functions. These teams use established practices like event storming to define requirements. New applications are designed as services well-defined boundaries and loosely coupling. Existing monoliths are decomposed into bounded contexts and system designs move towards SOA or microservice architectures. When monoliths are refactored, established approaches like bubble contexts and monolith decomposition patterns are applied.\n  \n    Domain-oriented services are executed as one or more processes that don\u2019t share state. They independently respond to fluctuations in demand and handle fault scenarios in light of domain specific requirements.\n  \nCommon anti-patterns:\n\n\n\n        Teams are formed around specific technical domains like UI and UX, middleware, or database instead of specific business domains.\n      \n\n\n        Applications span domain responsibilities. Services that span bounded contexts can be more difficult to maintain, require larger testing efforts, and require multiple domain teams to participate in software updates.\n      \n\n\n        Domain dependencies, like domain entity libraries, are shared across services such that changes for one service domain require changes to other service domains\n      \n\n\n        Service contracts and business logic don\u2019t express entities in a common and consistent domain language, resulting in translation layers that complicate systems and increase debugging efforts.\n      \n\nBenefits of establishing this best practice: Applications are designed as independent services bounded by business domains and use a common business language. Services are independently testable and deployable. Services meet domain specific resiliency requirements for the domain implemented. \n  \nLevel of risk exposed if this best practice\n    is not established: High\n  \nImplementation guidance\n\n      Domain-driven design (DDD) is the foundational approach of designing and building software around business domains. It\u2019s helpful to work with an existing framework when building services focused on business domains. When working with existing monolithic applications, you can take advantage of decomposition patterns that provide established techniques to modernize applications into services.   \n    \n\n\nDomain-driven design\n\n \nImplementation steps\n\n\n\n          Teams can hold event storming workshops to quickly identify events, commands, aggregates and domains in a lightweight sticky note format.\n          \n        \n\n\n          Once domain entities and functions have been formed in a domain context, you can divide your domain into services using bounded context, where entities that share similar features and attributes are grouped together. With the model divided into contexts, a template for how to boundary microservices emerges.\n        \n\n\n\n              For example, the Amazon.com website entities might include package, delivery, schedule, price, discount, and currency.\n            \n\n\n              Package, delivery, and schedule are grouped into the shipping context, while price, discount, and currency are grouped into the pricing context.\n            \n\n\n\nDecomposing monoliths into microservices outlines patterns for refactoring microservices. Using patterns for decomposition by business capability, subdomain, or transaction aligns well with domain-driven approaches.\n        \n\n\n          Tactical techniques such as the bubble context allow you to introduce DDD in existing or legacy applications without up-front rewrites and full commitments to DDD. In a bubble context approach, a small bounded context is established using a service mapping and coordination, or anti-corruption layer, which protects the newly defined domain model from external influences. \n        \n\n\n      After teams have performed domain analysis and defined entities and service contracts, they can take advantage of AWS services to implement their domain-driven design as cloud-based services.\n    \n\n\n\n          Start your development by defining tests that exercise business rules of your domain. Test-driven development (TDD) and behavior-driven development (BDD) help teams keep services focused on solving business problems.\n        \n\n\n          Select the AWS services that best meet your business domain requirements and microservice architecture:\n        \n\n\n\nAWS Serverless allows your team focus on specific domain logic instead of managing servers and infrastructure.\n            \n\n\nContainers at AWS simplify the management of your infrastructure, so you can focus on your domain requirements. \n            \n\n\nPurpose built databases help you match your domain requirements to the best fit database type.\n            \n\n\n\nBuilding hexagonal architectures on AWS outlines a framework to build business logic into services working backwards from a business domain to fulfill functional requirements and then attach integration adapters. Patterns that separate interface details from business logic with AWS services help teams focus on domain functionality and improve software quality.\n        \n\nResources\n\nRelated best practices:\n\n\n\n\nREL03-BP01 Choose how to segment your workload\n\n\n\nREL03-BP03 Provide service contracts per API\n\n\n\nRelated documents:\n\n\n\nAWS Microservices\n\n\nImplementing\n            Microservices on AWS\n\n\n\nHow\n            to break a Monolith into Microservices\n\n\n\nGetting\n          Started with DDD when Surrounded by Legacy Systems\n\n\n\n          Domain-Driven Design: Tackling Complexity in the Heart of Software\n        \n\n\n          Building hexagonal architectures on AWS\n\n\n          Decomposing monoliths into microservices\n        \n\n\n          Event Storming\n        \n\n\n          Messages Between Bounded Contexts\n        \n\n \n          Microservices\n        \n\n\n          Test-driven development\n        \n\n\n          Behavior-driven development\n        \n\n\nRelated examples:\n\n\n\n\n          Designing Cloud Native Microservices on AWS (from DDD/EventStormingWorkshop)\n        \n\n\nRelated tools:\n\n\n\nAWS Cloud Databases\n        \n\n\n          Serverless on AWS\n\n\n          Containers at AWS\n\n Javascript is disabled or is unavailable in your browser.To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.Document ConventionsREL03-BP01 Choose how to segment your workloadREL03-BP03 Provide service contracts per APIDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.", "metadata": {"source": "https://docs.aws.amazon.com/wellarchitected/latest/framework/rel_service_architecture_business_domains.html", "title": "REL03-BP02 Build services focused on specific business domains and functionality - AWS Well-Architected Framework", "description": "Service-oriented architectures (SOA) define services with well-delineated functions defined by business needs. Microservices use domain models and bounded context to draw service boundaries along business context boundaries. Focusing on business domains and functionality helps teams define independent reliability requirements for their services. Bounded contexts isolate and encapsulate business logic, allowing teams to better reason about how to handle failures.", "language": "en-US"}}