{"page_content": "REL05-BP01 Implement graceful degradation to transform applicable hard dependencies into soft dependencies - AWS Well-Architected FrameworkREL05-BP01 Implement graceful degradation to transform applicable hard dependencies into soft dependencies - AWS Well-Architected FrameworkAWSDocumentationAWS Well-ArchitectedFrameworkImplementation guidanceImplementation stepsResourcesREL05-BP01 Implement graceful degradation to transform\n  applicable hard dependencies into soft dependenciesApplication components should continue to perform their core function even if dependencies become unavailable. They might be serving slightly stale data, alternate data, or even no data. This ensures overall system function is only minimally impeded by localized failures while delivering the central business value.\nDesired outcome: When a component's dependencies are unhealthy, the component itself can still function, although in a degraded manner. Failure modes of components should be seen as normal operation. Workflows should be designed in such a way that such failures do not lead to complete failure or at least to predictable and recoverable states. \n  \nCommon anti-patterns:\n\n\n\n        Not identifying the core business functionality needed. Not testing that components are functional even during dependency failures.\n      \n\n\n        Serving no data on errors or when only one out of multiple dependencies is unavailable and partial results can still be returned.\n      \n\n\n        Creating an inconsistent state when a transaction partially fails.\n      \n\n\n        Not having an alternative way to access a central parameter store.\n      \n\n\n        Invalidating or emptying local state as a result of a failed refresh without considering the consequences of doing so.\n      \n\nBenefits of establishing this best practice: Graceful degradation improves the availability of the system as a whole and maintains the functionality of the most important functions even during failures. \n  \nLevel of risk exposed if this best practice\n    is not established: High\n  \nImplementation guidance\n\n  Implementing graceful degradation helps minimize the impact of dependency failures on component function. Ideally, a component detects dependency failures and works around them in a way that minimally impacts other components or customers.\n\n\n      Architecting for graceful degradation means considering potential failure modes during dependency design. For each failure mode, have a way to deliver most or at least the most critical functionality of the component to callers or customers. These considerations can become additional requirements that can be tested and verified. Ideally, a component is able to perform its core function in an acceptable manner even when one or multiple dependencies fail.\n    \n\n      This is as much a business discussion as a technical one. All business requirements are important and should be fulfilled if possible. However, it still makes sense to ask what should happen when not all of them can be fulfilled. A system can be designed to be available and consistent, but under circumstances where one requirement must be dropped, which one is more important? For payment processing, it might be consistency. For a real-time application, it might be availability. For a customer facing website, the answer may depend on customer expectations.\n    \n\n      What this means depends on the requirements of the component and what should be considered its core function. For example:\n    \n\n\n\n          An ecommerce website might display data from multiple different systems like personalized recommendations, highest ranked products, and status of customer orders on the landing page. When one upstream system fails, it still makes sense to display everything else instead of showing an error page to a customer.\n        \n\n\n          A component performing batch writes can still continue processing a batch if one of the individual operations fails. It should be simple to implement a retry mechanism. This can be done by returning information on which operations succeeded, which failed, and why they failed to the caller, or putting failed requests into a dead letter queue to implement asynchronous retries. Information about failed operations should be logged as well.\n        \n\n\n          A system that processes transactions must verify that either all or no individual updates are executed. For distributed transactions, the saga pattern can be used to roll back previous operations in case a later operation of the same transaction fails. Here, the core function is maintaining consistency.\n        \n\n\n          Time critical systems should be able to deal with dependencies not responding in a timely manner. In these cases, the circuit breaker pattern can be used. When responses from a dependency start timing out, the system can switch to a closed state where no additional call are made.\n        \n\n\n          An application may read parameters from a parameter store. It can be useful to create container images with a default set of parameters and use these in case the parameter store is unavailable.\n        \n\n\n      Note that the pathways taken in case of component failure need to be tested and should be significantly simpler than the primary pathway. Generally, fallback strategies should be avoided.\n    \nImplementation steps\n\n      Identify external and internal dependencies. Consider what kinds of failures can occur in them. Think about ways that minimize negative impact on upstream and downstream systems and customers during those failures.\n    \n\n      The following is a list of dependencies and how to degrade gracefully when they fail:\n    \n\n\n\nPartial failure of dependencies: A component may make multiple requests to downstream systems, either as multiple requests to one system or one request to multiple systems each. Depending on the business context, different ways of handling for this may be appropriate (for more detail, see previous examples in Implementation guidance).\n        \n\n\nA downstream system is unable to process requests due to high load: If requests to a downstream system are consistently failing, it does not make sense to continue retrying. This may create additional load on an already overloaded system and make recovery more difficult. The circuit breaker pattern can be utilized here, which monitors failing calls to a downstream system. If a high number of calls are failing, it will stop sending more requests to the downstream system and only occasionally let calls through to test whether the downstream system is available again.\n        \n\n\nA parameter store is unavailable: To transform a parameter store, soft dependency caching or sane defaults included in container or machine images may be used. Note that these defaults need to be kept up-to-date and included in test suites.\n        \n\n\nA monitoring service or other non-functional dependency is unavailable: If a component is intermittently unable to send logs, metrics, or traces to a central monitoring service, it is often best to still execute business functions as usual. Silently not logging or pushing metrics for a long time is often not acceptable. Also, some use cases may require complete auditing entries to fulfill compliance requirements.\n        \n\n\nA primary instance of a relational database may be unavailable: Amazon Relational Database Service, like almost all relational databases, can only have one primary writer instance. This creates a single point of failure for write workloads and makes scaling more difficult. This can partially be mitigated by using a Multi-AZ configuration for high availability or Amazon Aurora Serverless for better scaling. For very high availability requirements, it can make sense to not rely on the primary writer at all. For queries that only read, read replicas can be used, which provide redundancy and the ability to scale out, not just up. Writes can be buffered, for example in an Amazon Simple Queue Service queue, so that write requests from customers can still be accepted even if the primary is temporarily unavailable. \n        \n\nResources\n\nRelated documents:\n\n\n\n\nAmazon API Gateway: Throttle API Requests for Better\n          Throughput\n\n\n\nCircuitBreaker\n          (summarizes Circuit Breaker from \u201cRelease It!\u201d book)\n\n\n\nError\n          Retries and Exponential Backoff in AWS\n\n\n\nMichael\n          Nygard \u201cRelease It! Design and Deploy Production-Ready\n          Software\u201d\n\n\n\nThe\n          Amazon Builders' Library: Avoiding fallback in distributed\n          systems\n\n\n\nThe\n          Amazon Builders' Library: Avoiding insurmountable queue\n          backlogs\n\n\n\nThe\n          Amazon Builders' Library: Caching challenges and\n          strategies\n\n\n\nThe\n          Amazon Builders' Library: Timeouts, retries, and backoff with\n          jitter\n\n\n\nRelated videos:\n\n\n\n\nRetry,\n          backoff, and jitter: AWS re:Invent 2019: Introducing The\n          Amazon Builders\u2019 Library (DOP328)\n\n\n\nRelated examples:\n\n\n\n\nWell-Architected\n          lab: Level 300: Implementing Health Checks and Managing\n          Dependencies to Improve Reliability\n\n\n Javascript is disabled or is unavailable in your browser.To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.Document Conventions REL 5. How do you design interactions in a distributed system to mitigate\n                  or withstand failures? REL05-BP02 Throttle requestsDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.", "metadata": {"source": "https://docs.aws.amazon.com/wellarchitected/latest/framework/rel_mitigate_interaction_failure_graceful_degradation.html", "title": "REL05-BP01 Implement graceful degradation to transform applicable hard dependencies into soft dependencies - AWS Well-Architected Framework", "description": "Application components should continue to perform their core function even if dependencies become unavailable. They might be serving slightly stale data, alternate data, or even no data. This ensures overall system function is only minimally impeded by localized failures while delivering the central business value.", "language": "en-US"}}