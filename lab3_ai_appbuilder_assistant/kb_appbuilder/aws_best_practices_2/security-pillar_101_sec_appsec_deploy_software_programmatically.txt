{"page_content": "SEC11-BP06 Deploy software programmatically - Security PillarSEC11-BP06 Deploy software programmatically - Security PillarAWSDocumentationAWS Well-ArchitectedAWS Well-Architected FrameworkImplementation guidanceResourcesSEC11-BP06 Deploy software programmaticallyPerform software deployments programmatically where possible.\n    This approach reduces the likelihood that a deployment fails or an\n    unexpected issue is introduced due to human error.Desired outcome: Keeping people away from data is a key\n    principle of building securely in the AWS Cloud. This principle includes how you deploy your\n    software. \n      The benefits of not relying on people to deploy software is the\n      greater confidence that what you tested is what gets deployed, and\n      that the deployment is performed consistently every time. The\n      software should not need to be changed to function in different\n      environments. Using the principles of twelve-factor application\n      development, specifically the externalizing of configuration,\n      allows you to deploy the same code to multiple environments\n      without requiring changes. Cryptographically signing software\n      packages is a good way to verify that nothing has changed between\n      environments. The overall outcome of this approach is to reduce\n      risk in your change process and improve the consistency of\n      software releases.\n    Common anti-patterns: \n\n\n          Manually deploying software into production.\n        \n\n\n          Manually performing changes to software to cater to different\n          environments.\n        \nBenefits of establishing this best practice: \n\n\n          Increased confidence in the software release process.\n        \n\n\n          Reduced risk of a failed change impacting business\n          functionality.\n        \n\n\n          Increased release cadence due to lower change risk.\n        \n\n\n          Automatic rollback capability for unexpected events during\n          deployment.\n        \n\n\n          Ability to cryptographically prove that the software that was\n          tested is the software deployed.\n        \n\nLevel of risk exposed if this best practice is not established:\n    High \nImplementation guidance\n\n      Build your AWS account structure to remove persistent human access\n      from environments and use CI/CD tools to perform deployments.\n      Architect your applications so that environment-specific\n      configuration data is obtained from an external source, such as\n      AWS Systems Manager Parameter Store. Sign packages after they\n      have been tested, and validate these signatures during deployment.\n      Configure your CI/CD pipelines to push application code and use\n      canaries to confirm successful deployment. Use tools such as\n      AWS CloudFormation or\n      AWS CDK to\n      define your infrastructure, then use\n      AWS CodeBuild and\n      AWS CodePipeline to perform CI/CD operations.\n    \nImplementation steps \n\n\n\n            Build well-defined CI/CD pipelines to streamline the\n            deployment process.\n          \n\n\n            Using\n            AWS CodeBuild and\n            AWS             Code Pipeline to provide CI/CD capability makes it\n            simple to integrate security testing into your pipelines.\n          \n\n\n            Follow the guidance on separation of environments in the\n            Organizing\n            Your AWS Environment Using Multiple Accounts\n            whitepaper.\n          \n\n\n            Verify no persistent human access to environments where\n            production workloads are running.\n          \n\n\n            Architect your applications to support the externalization\n            of configuration data.\n          \n\n\n            Consider deploying using a blue/green deployment model.\n          \n\n\n            Implement canaries to validate the successful deployment of\n            software.\n          \n\n\n            Use cryptographic tools such as\n            AWS             Signer or\n            AWS Key Management Service (AWS KMS) to sign and verify the\n            software packages that you are deploying.\n          \n\nResources\n\nRelated best practices:\n\n\n\n\nSEC11-BP02 Automate testing throughout the development and\n  release lifecycle\n\n\n\nRelated documents:\n\n\n\n\nAWS           CI/CD Workshop\n\n\n\nAccelerate\n          deployments on AWS with effective governance\n\n\n\nAutomating\n          safe, hands-off deployments\n\n\n\nCode\n          signing using AWS Certificate Manager Private CA and AWS Key Management Service asymmetric keys\n\n\n\nCode\n          Signing, a Trust and Integrity Control for AWS Lambda\n\n\n\nRelated videos:\n\n\n\n\nHands-off:\n          Automating continuous delivery pipelines at\n          Amazon\n\n\n\nRelated examples:\n\n\n\n\nBlue/Green\n          deployments with AWS Fargate\n\n\n Javascript is disabled or is unavailable in your browser.To use the Amazon Web Services Documentation, Javascript must be enabled. Please refer to your browser's Help pages for instructions.Document ConventionsSEC11-BP05 Centralize services for packages and dependenciesSEC11-BP07 Regularly assess security properties of the\n  pipelinesDid this page help you? - YesThanks for letting us know we're doing a good job!If you've got a moment, please tell us what we did right so we can do more of it.Did this page help you? - NoThanks for letting us know this page needs work. We're sorry we let you down.If you've got a moment, please tell us how we can make the documentation better.", "metadata": {"source": "https://docs.aws.amazon.com/wellarchitected/latest/security-pillar/sec_appsec_deploy_software_programmatically.html", "title": "SEC11-BP06 Deploy software programmatically - Security Pillar", "description": "Perform software deployments programmatically where possible. This approach reduces the likelihood that a deployment fails or an unexpected issue is introduced due to human error.", "language": "en-US"}}